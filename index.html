<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Points CSV + Scatter Plot</title>
  <style>
    body { font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Arial; padding: 24px; background:#fafafa; color:#111 }
    h1 { margin:0 0 12px 0 }
    .controls { display:flex; gap:8px; align-items:center; margin-bottom:12px }
    button { padding:8px 12px; border-radius:6px; border:1px solid #ccc; background:white; cursor:pointer }
    button:hover { box-shadow:0 1px 3px rgba(0,0,0,0.08) }
    #csv { width:100%; height:160px; font-family: monospace; padding:8px; box-sizing:border-box; border-radius:6px; border:1px solid #ddd }
    .row { display:block; gap:16px }
     /* make the plot a responsive square and place it below the points list
       set to 25% of page width; include a min-width for small screens */
    /* 25% of the viewport width so the plot is a quarter of the page width */
    canvas { width:25vw; min-width:200px; aspect-ratio: 1 / 1; display:block; border-radius:6px; background:linear-gradient(#fff,#f6f6f6); border:1px solid #e6e6e6 }
    .meta { color:#555; font-size:13px }
    @media (max-width:900px){ .row{ grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <h1>Random Points â€” CSV & Scatter Plot</h1>
  <p class="meta">Generates 50 random (x,y) points. Copy or download as CSV, and view a scatter plot.</p>

  <div class="controls">
    <button id="regen">Regenerate</button>
    <button id="copy">Copy CSV</button>
    <a id="download" href="#" download="points.csv"><button>Download CSV</button></a>
    <label style="margin-left:auto; font-size:13px; color:#444">Points: <strong id="count">50</strong></label>
  </div>

  <div class="row">
    <div>
      <textarea id="csv" readonly></textarea>
    </div>
    <div style="margin-top:12px">
      <div class="plot-row" style="display:flex; gap:12px; align-items:flex-start">
        <div style="display:flex; flex-direction:column; gap:8px; align-items:flex-start">
          <canvas id="plot" width="200" height="200"></canvas>
          <div id="lineStats" style="font-size:13px; color:#333">
            <div>A: <strong id="statA">-</strong></div>
            <div>B: <strong id="statB">-</strong></div>
            <div>Loss: <strong id="statLoss">-</strong></div>
          </div>
        </div>
        <div class="line-panel" style="flex:1; min-width:220px">
          <label style="font-size:13px; color:#333; display:block; margin-bottom:6px">Line CSV y = ax+b (paste rows of <code>a,b</code>)</label>
          <textarea id="lineCsv" placeholder="a,b\n0.5,1\n0.6,0.8" style="width:100%; height:160px; font-family: monospace; padding:8px; box-sizing:border-box; border-radius:6px; border:1px solid #ddd"></textarea>
          <div style="display:flex; gap:8px; margin-top:8px; align-items:center">
            <button id="plotLine">Play</button>
            <button id="stopLine">Stop</button>
            <div style="margin-left:auto; font-size:13px; color:#444">Index: <strong id="lineIndex">-</strong></div>
          </div>
        </div>
        <div class="loss-panel" style="min-width:200px">
          <label style="font-size:13px; color:#333; display:block; margin-bottom:6px">Loss surface (a,b)</label>
          <canvas id="lossPlot"></canvas>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Configuration
    const N = 50;

    // Generate dataset: array of {x,y} with values in [0,10]
    function generateData(n){
      const pts = [];
      for(let i=0;i<n;i++){
        // Uniform random points in [0,10]
        const x = Math.random() * 10;
        const y = Math.random() * 10;
        pts.push({x,y});
      }
      return pts;
    }

    // Convert to CSV string
    function toCSV(points){
      let out = 'x,y\n';
      for(const p of points){
        out += `${Number(p.x).toFixed(3)},${Number(p.y).toFixed(3)}\n`;
      }
      return out;
    }

    // Canvas plotting
    // Accepts optional `line` object: {a:number, b:number, color?:string}
    function drawScatter(canvas, points, line){
      const ctx = canvas.getContext('2d');
      const DPR = window.devicePixelRatio || 1;
      // Use the client size for layout stability (don't change page layout on redraw)
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      canvas.width = Math.round(width * DPR);
      canvas.height = Math.round(height * DPR);
      ctx.setTransform(DPR,0,0,DPR,0,0);

      // Clear
      ctx.clearRect(0,0,width,height);

      // margins
      const m = {l:40, r:16, t:16, b:40};
      const w = width - m.l - m.r;
      const h = height - m.t - m.b;

      // find extents with small padding
      const xs = points.map(p=>p.x);
      const ys = points.map(p=>p.y);
      const xmin = Math.min(...xs);
      const xmax = Math.max(...xs);
      const ymin = Math.min(...ys);
      const ymax = Math.max(...ys);
      const padX = (xmax-xmin)*0.08 || 1;
      const padY = (ymax-ymin)*0.08 || 1;

      function sx(x){ return m.l + ((x - (xmin - padX)) / ((xmax + padX) - (xmin - padX))) * w; }
      function sy(y){ return m.t + h - ((y - (ymin - padY)) / ((ymax + padY) - (ymin - padY))) * h; }

      // background
      ctx.fillStyle = '#fff';
      ctx.fillRect(0,0,width,height);

      // grid lines
      ctx.strokeStyle = '#eee';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for(let i=0;i<=4;i++){
        const yy = m.t + (h/4)*i;
        ctx.moveTo(m.l, yy);
        ctx.lineTo(m.l + w, yy);
      }
      ctx.stroke();

      // axes
      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      // x axis
      ctx.moveTo(m.l, m.t + h);
      ctx.lineTo(m.l + w, m.t + h);
      // y axis
      ctx.moveTo(m.l, m.t);
      ctx.lineTo(m.l, m.t + h);
      ctx.stroke();

      // ticks and labels (simple)
      ctx.fillStyle = '#444';
      ctx.font = '12px system-ui, Arial';
      ctx.textAlign = 'center';
      for(let i=0;i<=4;i++){
        const xval = xmin + (xmax - xmin) * (i/4);
        const xpos = sx(xval);
        ctx.fillText(xval.toFixed(1), xpos, m.t + h + 15);
      }
      ctx.textAlign = 'right';
      for(let i=0;i<=4;i++){
        const yval = ymin + (ymax - ymin) * (i/4);
        const ypos = sy(yval);
        ctx.fillText(yval.toFixed(1), m.l - 8, ypos + 4);
      }

      // points
      for(const p of points){
        const x = sx(p.x);
        const y = sy(p.y);
        ctx.beginPath();
        ctx.fillStyle = 'rgba(33,150,243,0.85)';
        ctx.strokeStyle = 'rgba(15,76,129,0.9)';
        ctx.lineWidth = 0.6;
        ctx.arc(x, y, 4, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
      }

      // optional line overlay y = a*x + b
      if(line && typeof line.a === 'number' && typeof line.b === 'number'){
        const a = line.a;
        const b = line.b;
        const color = line.color || 'rgba(220,50,50,0.95)';
        // use current x-domain with padding for endpoints
        const x0 = xmin - padX;
        const x1 = xmax + padX;
        const y0 = a * x0 + b;
        const y1 = a * x1 + b;
        const px0 = sx(x0);
        const py0 = sy(y0);
        const px1 = sx(x1);
        const py1 = sy(y1);
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.moveTo(px0, py0);
        ctx.lineTo(px1, py1);
        ctx.stroke();
      }

      // title
      ctx.fillStyle = '#222';
      ctx.font = '13px system-ui, Arial';
      ctx.textAlign = 'left';
      ctx.fillText('Scatter plot of points', m.l, m.t - 2);
    }

    // UI wiring
    (function(){
      const regenBtn = document.getElementById('regen');
      const copyBtn = document.getElementById('copy');
      const downloadA = document.getElementById('download');
      const csvEl = document.getElementById('csv');
      const canvas = document.getElementById('plot');
      const lineCsvEl = document.getElementById('lineCsv');
      const plotLineBtn = document.getElementById('plotLine');
      const stopLineBtn = document.getElementById('stopLine');
      const lineIndexEl = document.getElementById('lineIndex');
      const countEl = document.getElementById('count');
      const statAEl = document.getElementById('statA');
      const statBEl = document.getElementById('statB');
      const statLossEl = document.getElementById('statLoss');
      const lossCanvas = document.getElementById('lossPlot');

      // loss grid cache: {aMin,aMax,bMin,bMax,cols,rows,values,min,max}
      let lossGrid = null;
      // Camera for 3D loss plot
      let camPitch = 0.65; // rotation around X (vertical)
      let camYaw = -0.6;   // rotation around Y (horizontal)
      let camZoom = 1.0;   // zoom multiplier
      // pointer interaction state
      const pointers = new Map();
      let lastPinchDist = null;

      let data = [];
      // line animation state
      let linePairs = [];
      let lineIndex = -1;
      let lineInterval = null;

      function updateAll(newData){
        data = newData;
        countEl.textContent = data.length;
        const csv = toCSV(data);
        csvEl.value = csv;
        // update download link using blob
        const blob = new Blob([csv], {type: 'text/csv'});
        const url = URL.createObjectURL(blob);
        downloadA.href = url;
        // redraw with current line if active
        if(linePairs.length && lineIndex >= 0){
          const lp = linePairs[lineIndex];
          drawScatter(canvas, data, lp);
          updateLineStats(lp);
        } else {
          drawScatter(canvas, data);
          updateLineStats(null);
        }
      }

      regenBtn.addEventListener('click', ()=>{
        updateAll(generateData(N));
      });

      copyBtn.addEventListener('click', async ()=>{
        try{
          await navigator.clipboard.writeText(csvEl.value);
          copyBtn.textContent = 'Copied!';
          setTimeout(()=>copyBtn.textContent='Copy CSV',1200);
        }catch(e){
          // fallback: select and execCommand
          csvEl.select();
          document.execCommand('copy');
          copyBtn.textContent = 'Copied!';
          setTimeout(()=>copyBtn.textContent='Copy CSV',1200);
        }
      });

      // initial
      updateAll(generateData(N));

      function parseLineCsv(text){
        const out = [];
        const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
        for(const l of lines){
          if(/^\s*a\s*,\s*b\s*$/i.test(l)) continue;
          const parts = l.split(',').map(s=>s.trim());
          if(parts.length < 2) continue;
          const a = Number(parts[0]);
          const b = Number(parts[1]);
          if(Number.isFinite(a) && Number.isFinite(b)) out.push({a,b});
        }
        return out;
      }

      function computeLoss(a,b){
        // MSE between line y = a*x + b and current data
        if(!data || data.length === 0) return NaN;
        let s = 0;
        for(const p of data){
          const yhat = a * p.x + b;
          const e = p.y - yhat;
          s += e*e;
        }
        return s / data.length;
      }

      function buildLossGrid(aMin,aMax,bMin,bMax,cols=60,rows=40){
        const values = new Array(rows);
        let min = Infinity, max = -Infinity;
        for(let j=0;j<rows;j++){
          values[j] = new Array(cols);
          const t = j/(rows-1);
          const b = bMin + t*(bMax - bMin);
          for(let i=0;i<cols;i++){
            const s = i/(cols-1);
            const a = aMin + s*(aMax - aMin);
            const z = computeLoss(a,b);
            values[j][i] = z;
            if(z < min) min = z;
            if(z > max) max = z;
          }
        }
        return {aMin,aMax,bMin,bMax,cols,rows,values,min,max};
      }

      // Draw the loss surface as a simple 3D mesh using canvas projection
      function drawLossSurface(canvas, grid){
        const ctx = canvas.getContext('2d');
        const w = canvas.clientWidth; const h = canvas.clientHeight;
        const DPR = window.devicePixelRatio || 1;
        canvas.width = Math.round(w * DPR);
        canvas.height = Math.round(h * DPR);
        ctx.setTransform(DPR,0,0,DPR,0,0);
        ctx.clearRect(0,0,w,h);
        if(!grid) return;
        const {cols,rows,values,min,max,aMin,aMax,bMin,bMax} = grid;

        // Camera / projection settings (use interactive globals)
        const pitch = camPitch; // rotateX
        const yaw = camYaw;     // rotateY
        const scale = camZoom * (Math.min(w,h) * 0.9);

        // precompute trig
        const cosX = Math.cos(pitch), sinX = Math.sin(pitch);
        const cosY = Math.cos(yaw), sinY = Math.sin(yaw);

        // compute 3D points grid projected to 2D
        const pts = new Array(rows);
        for(let j=0;j<rows;j++){
          pts[j] = new Array(cols);
          const ty = j/(rows-1);
          const b = bMin + ty * (bMax - bMin);
          for(let i=0;i<cols;i++){
            const tx = i/(cols-1);
            const a = aMin + tx * (aMax - aMin);
            const z = values[j][i];
            const zn = (z - min) / (max - min || 1); // 0..1

            // map to centered 3D coordinates
            const x3 = (tx - 0.5) * (aMax - aMin);
            const y3 = (ty - 0.5) * (bMax - bMin);
            const z3 = zn * (max - min || 1);

            // rotate Y then X
            const rx = x3 * cosY + z3 * sinY;
            const rz = -x3 * sinY + z3 * cosY;
            const ry = y3 * cosX - rz * sinX;
            const rz2 = y3 * sinX + rz * cosX;

            // project to screen
            const px = w/2 + rx * scale * 0.18;
            const py = h/2 - ry * scale * 0.18;
            pts[j][i] = {px, py, depth: rz2, a, b, z};
          }
        }

        // draw polygons back-to-front: iterate rows from 0..rows-2 or reverse depending on view
        for(let j=rows-2;j>=0;j--){
          for(let i=0;i<cols-1;i++){
            const p00 = pts[j][i];
            const p10 = pts[j][i+1];
            const p01 = pts[j+1][i];
            const p11 = pts[j+1][i+1];
            // average depth for simple painter ordering (not used here)
            const avgZ = (p00.depth + p10.depth + p01.depth + p11.depth)/4;
            // color by average z (loss)
            const avgLoss = (p00.z + p10.z + p01.z + p11.z)/4;
            const t = (avgLoss - min) / (max - min || 1);
            ctx.fillStyle = interpColor(t);
            ctx.beginPath();
            ctx.moveTo(p00.px, p00.py);
            ctx.lineTo(p10.px, p10.py);
            ctx.lineTo(p11.px, p11.py);
            ctx.lineTo(p01.px, p01.py);
            ctx.closePath();
            ctx.fill();
            // subtle stroke
            ctx.strokeStyle = 'rgba(0,0,0,0.06)';
            ctx.lineWidth = 0.5;
            ctx.stroke();
          }
        }

        // draw 3D axes (a, b, loss) by projecting axis endpoints
        (function drawAxes(){
          ctx.save();
          ctx.lineWidth = 1.2;
          ctx.strokeStyle = 'rgba(0,0,0,0.6)';
          ctx.fillStyle = '#111';
          ctx.font = '12px system-ui, Arial';

          // helper to project 3D point (x3,y3,z3) to screen using same transforms above
          function project(x3,y3,z3){
            const rx = x3 * cosY + z3 * sinY;
            const rz = -x3 * sinY + z3 * cosY;
            const ry = y3 * cosX - rz * sinX;
            const px = w/2 + rx * scale * 0.18;
            const py = h/2 - ry * scale * 0.18;
            return {px,py,depth: y3 * sinX + rz * cosX};
          }

          // axis base at (aMin, bMin, z=min)
          const baseA = -0.5 * (aMax - aMin);
          const baseB = -0.5 * (bMax - bMin);
          const baseZ = 0; // zn=0 corresponds to min

          // endpoints in normalized x3/y3/z3 space matching mesh mapping
          const aStart = {x: baseA, y: baseB, z: baseZ};
          const aEnd = {x: 0.5 * (aMax - aMin), y: baseB, z: baseZ};
          const bEnd = {x: baseA, y: 0.5 * (bMax - bMin), z: baseZ};
          const zEnd = {x: baseA, y: baseB, z: (max - min || 1)};

          const pBase = project(aStart.x, aStart.y, aStart.z);
          const pA = project(aEnd.x, aEnd.y, aEnd.z);
          const pB = project(bEnd.x, bEnd.y, bEnd.z);
          const pZ = project(zEnd.x, zEnd.y, zEnd.z);

          // draw axis lines
          ctx.beginPath();
          ctx.moveTo(pBase.px, pBase.py);
          ctx.lineTo(pA.px, pA.py);
          ctx.moveTo(pBase.px, pBase.py);
          ctx.lineTo(pB.px, pB.py);
          ctx.moveTo(pBase.px, pBase.py);
          ctx.lineTo(pZ.px, pZ.py);
          ctx.stroke();

          // ticks & numeric labels (3 ticks each)
          function drawTicks(start, end, n, labelFn){
            for(let t=0;t<=n;t++){
              const u = t/n;
              const x = start.x + (end.x - start.x) * u;
              const y = start.y + (end.y - start.y) * u;
              const z = start.z + (end.z - start.z) * u;
              const pp = project(x,y,z);
              // small tick orthogonal vector (screen-space) approximate
              ctx.beginPath();
              ctx.moveTo(pp.px-4, pp.py-4);
              ctx.lineTo(pp.px+4, pp.py+4);
              ctx.stroke();
              const lbl = labelFn ? labelFn(u) : '';
              if(lbl !== '') ctx.fillText(lbl, pp.px + 6, pp.py - 6);
            }
          }

          // a axis labels: map u to actual a value
          drawTicks(aStart, aEnd, 4, u => (aMin + u*(aMax-aMin)).toFixed(2));
          // b axis labels
          drawTicks(aStart, bEnd, 4, u => (bMin + u*(bMax-bMin)).toFixed(2));
          // z axis labels (loss) use min..max
          drawTicks(aStart, zEnd, 4, u => (min + u*(max-min)).toFixed(2));

          // axis names
          ctx.fillStyle = '#000'; ctx.textAlign = 'center';
          ctx.fillText('a', pA.px + 8, pA.py);
          ctx.fillText('b', pB.px + 8, pB.py);
          ctx.fillText('loss', pZ.px + 8, pZ.py);

          ctx.restore();
        })();
      }

      function interpColor(t){
        // clamp
        t = Math.max(0, Math.min(1, t));
        // simple blue->cyan->yellow->red
        const r = Math.round(255 * Math.min(1, Math.max(0, (t-0.5)*2)) + 0 * Math.min(1, Math.max(0, 1-(t*2))));
        const g = Math.round(255 * (t < 0.5 ? (t*2) : (1 - (t-0.5)*2)));
        const b = Math.round(255 * Math.min(1, Math.max(0, 1 - t*2)));
        return `rgb(${r},${g},${b})`;
      }

      function ensureLossGrid(){
        // determine ranges from CSV if available, otherwise defaults
        const parsed = parseLineCsv(lineCsvEl.value || '');
        let aMin=-2, aMax=2, bMin=-5, bMax=5;
        if(parsed.length){
          const as = parsed.map(p=>p.a); const bs = parsed.map(p=>p.b);
          const amin = Math.min(...as); const amax = Math.max(...as);
          const bmin = Math.min(...bs); const bmax = Math.max(...bs);
          const padA = (amax-amin)*0.15 || 1;
          const padB = (bmax-bmin)*0.15 || 1;
          aMin = amin - padA; aMax = amax + padA;
          bMin = bmin - padB; bMax = bmax + padB;
        }
        lossGrid = buildLossGrid(aMin,aMax,bMin,bMax,80,60);
        drawLossSurface(lossCanvas, lossGrid);
        // attach interaction handlers once
        attachLossInteractions();
      }

      function attachLossInteractions(){
        if(!lossCanvas) return;
        // avoid adding multiple listeners
        if(lossCanvas._interactive) return;
        lossCanvas._interactive = true;

        // pointer events allow multi-touch (pinch) and mouse
        lossCanvas.addEventListener('pointerdown', e => {
          lossCanvas.setPointerCapture(e.pointerId);
          pointers.set(e.pointerId, {x: e.clientX, y: e.clientY});
          lastPinchDist = null;
          lossCanvas.style.cursor = 'grabbing';
        });

        lossCanvas.addEventListener('pointermove', e => {
          if(!pointers.size) return;
          if(!pointers.has(e.pointerId)) return;
          pointers.set(e.pointerId, {x: e.clientX, y: e.clientY});

          if(pointers.size === 1){
            // rotate
            const p = Array.from(pointers.values())[0];
            // we need previous position - estimate from event (use movementX/Y if available)
            const dx = e.movementX || 0;
            const dy = e.movementY || 0;
            camYaw += dx * 0.01;
            camPitch += dy * 0.01;
            camPitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, camPitch));
            drawLossSurface(lossCanvas, lossGrid);
            // if currently animating, redraw point
            if(linePairs.length && lineIndex >= 0) drawLossPoint(linePairs[lineIndex].a, linePairs[lineIndex].b);
          } else if(pointers.size === 2){
            // pinch to zoom
            const arr = Array.from(pointers.values());
            const dx = arr[0].x - arr[1].x;
            const dy = arr[0].y - arr[1].y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(lastPinchDist != null){
              const ratio = dist / lastPinchDist;
              camZoom *= ratio;
              camZoom = Math.max(0.2, Math.min(6, camZoom));
              drawLossSurface(lossCanvas, lossGrid);
              if(linePairs.length && lineIndex >= 0) drawLossPoint(linePairs[lineIndex].a, linePairs[lineIndex].b);
            }
            lastPinchDist = dist;
          }
        });

        lossCanvas.addEventListener('pointerup', e => {
          try{ lossCanvas.releasePointerCapture(e.pointerId); }catch(_){ }
          pointers.delete(e.pointerId);
          lastPinchDist = null;
          if(pointers.size === 0) lossCanvas.style.cursor = 'default';
        });

        lossCanvas.addEventListener('pointercancel', e => {
          pointers.delete(e.pointerId);
          lastPinchDist = null;
          if(pointers.size === 0) lossCanvas.style.cursor = 'default';
        });

        // wheel to zoom
        lossCanvas.addEventListener('wheel', e => {
          e.preventDefault();
          const delta = -e.deltaY;
          const factor = 1 + (delta>0?0.08:-0.08);
          camZoom *= factor;
          camZoom = Math.max(0.2, Math.min(6, camZoom));
          drawLossSurface(lossCanvas, lossGrid);
          if(linePairs.length && lineIndex >= 0) drawLossPoint(linePairs[lineIndex].a, linePairs[lineIndex].b);
        }, {passive:false});
      }

      function drawLossPoint(a,b){
        if(!lossGrid) ensureLossGrid();
        const ctx = lossCanvas.getContext('2d');
        const w = lossCanvas.clientWidth; const h = lossCanvas.clientHeight;
        const {aMin,aMax,bMin,bMax,min,max,cols,rows,values} = lossGrid;
        // rebuild projected grid to find projected coords for the point
        // reuse same projection math as drawLossSurface
        const pitch = camPitch; const yaw = camYaw; const scale = camZoom * (Math.min(w,h) * 0.9);
        const cosX = Math.cos(pitch), sinX = Math.sin(pitch);
        const cosY = Math.cos(yaw), sinY = Math.sin(yaw);

        // compute normalized tx,ty for point
        const tx = (a - aMin) / (aMax - aMin);
        const ty = (b - bMin) / (bMax - bMin);
        const z = computeLoss(a,b);
        const zn = (z - min) / (max - min || 1);
        const x3 = (tx - 0.5) * (aMax - aMin);
        const y3 = (ty - 0.5) * (bMax - bMin);
        const z3 = zn * (max - min || 1);
        const rx = x3 * cosY + z3 * sinY;
        const rz = -x3 * sinY + z3 * cosY;
        const ry = y3 * cosX - rz * sinX;
        // project
        const px = w/2 + rx * scale * 0.18;
        const py = h/2 - ry * scale * 0.18;

        // redraw surface
        drawLossSurface(lossCanvas, lossGrid);

        // draw point
        ctx.beginPath(); ctx.fillStyle = 'black'; ctx.strokeStyle = '#fff'; ctx.lineWidth = 1.5;
        ctx.arc(px, py, 6, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.fillStyle = '#000'; ctx.font = '12px system-ui, Arial'; ctx.textAlign = 'left';
        ctx.fillText(`${a.toFixed(3)}, ${b.toFixed(3)}, loss=${(Number.isFinite(z)?z.toFixed(6):'-')}`, px + 8, py - 8);
      }

      function stopLineAnimation(){
        if(lineInterval){ clearInterval(lineInterval); lineInterval = null; }
        plotLineBtn.textContent = 'Play';
      }

      function startLineAnimation(){
        if(linePairs.length === 0) return;
        if(lineInterval) clearInterval(lineInterval);
        plotLineBtn.textContent = 'Pause';
        // ensure index
        if(lineIndex < 0) lineIndex = 0;
        lineIndexEl.textContent = (lineIndex+1) + '/' + linePairs.length;
        drawScatter(canvas, data, linePairs[lineIndex]);
        updateLineStats(linePairs[lineIndex]);
        drawLossPoint(linePairs[lineIndex].a, linePairs[lineIndex].b);
        // advance through pairs until the last one, then stop (no looping)
        lineInterval = setInterval(()=>{
          lineIndex = lineIndex + 1;
          if(lineIndex >= linePairs.length){
            // reached past the end: clamp to last, draw it, then stop
            lineIndex = linePairs.length - 1;
            lineIndexEl.textContent = (lineIndex+1) + '/' + linePairs.length;
            drawScatter(canvas, data, linePairs[lineIndex]);
            stopLineAnimation();
            return;
          }
          lineIndexEl.textContent = (lineIndex+1) + '/' + linePairs.length;
          drawScatter(canvas, data, linePairs[lineIndex]);
          updateLineStats(linePairs[lineIndex]);
          drawLossPoint(linePairs[lineIndex].a, linePairs[lineIndex].b);
        }, 800);
      }

      plotLineBtn.addEventListener('click', ()=>{
        if(lineInterval){ stopLineAnimation(); return; }
        // parse CSV
        const parsed = parseLineCsv(lineCsvEl.value || '');
        if(parsed.length > 0){ linePairs = parsed; lineIndex = 0; ensureLossGrid(); startLineAnimation(); return; }
        // if no CSV parsed, do nothing (user can paste CSV then Play)
      });

      stopLineBtn.addEventListener('click', ()=>{
        stopLineAnimation();
      });

      // redraw on resize (keep stats in sync)
      let rTO;
      window.addEventListener('resize', ()=>{
        clearTimeout(rTO);
        rTO = setTimeout(()=>{
          if(linePairs.length && lineIndex >= 0){
            drawScatter(canvas, data, linePairs[lineIndex]);
            updateLineStats(linePairs[lineIndex]);
          } else {
            drawScatter(canvas, data);
            updateLineStats(null);
          }
        }, 120);
      });

      function updateLineStats(line){
        if(line && typeof line.a === 'number' && typeof line.b === 'number'){
          const a = line.a; const b = line.b;
          statAEl.textContent = Number(a).toFixed(6);
          statBEl.textContent = Number(b).toFixed(6);
          // compute MSE
          if(data && data.length){
            let s = 0;
            for(const p of data){
              const yhat = a * p.x + b;
              const e = p.y - yhat;
              s += e*e;
            }
            const mse = s / data.length;
            statLossEl.textContent = mse.toFixed(6);
          } else {
            statLossEl.textContent = '-';
          }
        } else {
          statAEl.textContent = '-';
          statBEl.textContent = '-';
          statLossEl.textContent = '-';
        }
      }
    })();
  </script>
</body>
</html>
